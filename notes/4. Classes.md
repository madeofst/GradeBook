## Classes

We know the rules by now, you have class *fields* which are the variables and are private to the class.  We have methods which are functions.  Public methods are those available to users of the class e.g. `myClass.method` and private ones are only accesible within the class.

You should build each class with the namespace of your program *?! I think ?!*

If you create a new class file (.cs) in the project folder, it will immediately be available to other .cs files in the folder, if the class is within the same namespace. *?! I think ?!*

Each class should be its own file with the name of the file as the name of the class. (Good practice)

```cs
namespace GradeBook
{
    class Book
    {   
        //Some fields
        private double numberVariable
        private List listOfDoubles = new List(); //new empty list
        //Can't use var here

        //A method
        public void AddGrade(double Grade) 
        //public for access outside the class
        //void means it doesn't return anything *?! I think ?!*
        {
            listOfDoubles.Add(43.5);
        }
    }
}

```
### Construtor method

Just write a method with the same name as the class, with no return type.
```cs
namespace GradeBook
{
    class Book
    {   
        private List<double> listOfDoubles;

        public Book() 
        {
            listOfDoubles = new List<double>());
        }
    }
}
```
You can assign parameters to a constructor, so that when an instance is created, the user has to provide the parameter.  You can then do what you want with the parameter value in the constructor.

```cs
namespace GradeBook
{
    class Book
    {   
        private string name;

        public Book(string name) 
        {
            this.name = name;
        }
    }
}
```

In this case, you can also the `this` keyword to refer to the current **object**.  In this example it prevents the complier getting confused between two variables called `name`, but makes it easier to read with them both being just called `name`.

Without `this`, the compiler assumes that the *nearest* definition of `name` is the one being referred to - in the above example the nearest definition is in the parameter to the constructor method.

You can leave it off most of the time, unless there is a name conflict.


### Access modifiers
This is what we call the keywords that control access e.g.
```cs
public  //it's accesible outside the class
private //it's only accesible within the class
        //this limits the potential for things to go wrong 
        //by preventing things like illegal value entry
static  //it relates to the class, not to instances of the class
internal//it can only be used within the current project
```
If you omit one fo these, it defaults to `private` for a method in a class.  For the class itself it defaults to `internal`.  You will need to change the class to `public` to use it outside the project.

> `Static` members, like the main method in the program class, are not methods you can use on an instance of a class.  For example, if you create an instance of a class `Book` with the follow:

```cs
static main();
{
    //some code
}
public action();
{
    //some code
}
```

The following rules would apply.

```cs
Book instanceOfBook = new Book();
instanceOfBook.action();    //This is fine
Book.action();              //This won't run
instanceOfBook.main();      //This won't run
Book.main();                //However this will.
```
You can also have static fields.  

Static members exist only once in a program because the class only exists once.  Public and private members will exist for each instance of the class.

Static members are less common since they negate the object-oriented aspect of the approach.  They are commonly useful for example, in a 'toolbox'-type class.

`Program.Main` is static.  `Console.WriteLine()` is also static.

Another example is when you are finding the highest value in a list.  If you want to start a variable off with as low a value as possible, depending on the numeric type you are using, you can using a static member of the numeric type class:

```cs
double number = 1.2;
double highGrade = double.MinValue;
//MinValue is a static member of the double class
highGrade = Math.Max(number,highGrade); 
//Max is also a static member of the Math class
```

### Auto generate method in VS Code

If you are planning to create a new method, you can write the implementation of the method and use a vscode shortcut to create it.  You just type how you want to use it then hit `Ctrl+.`

```cs
Book.newMethod();   //Write this, the hit Ctrl+.
```

### Typing conventions re: case

C# is case sensitive.  The convention is to name public members with a capital letter and private members with a lower case first letter.


# Building Types

### Method overloading

You can use the same name for multiple methods as long as the 'signature' of the methods are different.  The 'signature' includes the parameters but not the return type.  This just means you can't write two methods with the same name and same input parameters but different return types.  This makes sense, because the compiler wouldn't know which method was being called, as the calling and inputs would be identical.

However, if you wanted to allow the user to input either a numerical grade or a letter value, you could overload the method by writing the following:

```cs
public void AddGrade(char letter)
{   
    double grade;
    switch(letter)
    {
        case 'A':
            grade = 90;
            break;
        case 'B':
            grade = 80;
            break;
        case 'C':
            grade = 70;
            break;
        case 'D':
            grade = 60;
            break;
        case 'E':
            grade = 50;
            break;
        default:
            grade = 40;
            break;
    }
    AddGrade(grade);
}

public void AddGrade(double grade)
{
    Console.WriteLine(grade);
}
```


### Properties

These are the same as vba, but with better syntax.  Here is the basic version:

```cs

private string name;

public string Name
{
    get
    {
        return name;
    }
    set
    {
        if(!String.IsNullOrEmpty(value))
        {
            name = value;
        }
    }
}
```

The key things to remember here are that the keyword value is implicit.  It's not physically shown in the code, but it represents whatever value was passed to the property input.

### Auto-property

If all you want to do is get the value of the variable and set the value of the variable, you can write a vert short-hand bit of syntax called an auto-property.

```cs
public string Name
{
    get; set;
}
```

With this, you don't even have to write the underlying private variable.  In a lot of cases, this isn't any different but in some cases in dotnet uses properties and public variables differently.  Probably don't need to worry about it.  


## Read-only members

### Read-only properties

One time where you can use the above property syntax is for a read-only property a.k.a. if you want to make the `set` private:

```cs
public string Name
{
    get; 
    private set;
}
```

Under this use case, the user can get the value of the variable, but can't overwrite it (perhaps you want to force the user to call a class methods to write the variable).


### The readonly keyword

One way you can make read-only members is to use the `readonly` keyword:

```cs
class Film
{
    readonly string genre = "Western";

    public Film();
    {
        genre = "Science Fiction";
    }    
}
```

A readonly member variable like this can only be written to when it is initialized, or in the class constructor.  You will get a complier error if you try to write to it at any other time.

### The const keyword

Constants are similar, except it can *only* be written to at initialization.

```cs
class Film
{
    const string GENRE = "Western";
}
```

Constants can also be `public` or `private`.  When consts are public, there is no need to wrap them in a property as they can never be changed and can be used safely publicly.

> A common convention is to write constant variable names in ALLUPPERCASE. This is just potentially useful.

Public constants are referenced outside the class in same way as static methods. So if you have the `Book` class and the object instance `book1`, you would access the constant variable with:

```cs
string g = Book.GENRE;  //Correct
//NOT
string g = book1.GENRE;  //Incorrect
```
